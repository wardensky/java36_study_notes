# 谈谈你知道的设计模式？

设计模式在刚刚工作的时候就开始看，那个时候有很多都看不明白。最近再拿起来看，发现很多都在工作中应用。


- 创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。
- 结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。
- 行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。


## 创建型模式

### 工厂模式（FactoryMethod）

这个太常见了，不说了。

### 单例模式（Singleton）

用的最熟悉的模式之一，要记住懒加载、双重检查锁、枚举单例，还有一个新的内部类实现。



### 构建器模式（Prototype）

构建器模式和抽象工厂模式主要的区别就就是，构建器模式一步步创建对象，所以及时展开输出创建过程似乎很重要。

代码如下：

```
A a = new A.Builder().seta(1).setb(2).setc(3).build();
```

这个在开发中也用过。


### 原型模式

原型模式主要通过深拷贝实现对象的创建，之前用过。


## 结构型模式

### 桥接模式（Adapter）

这个也常用。

将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能在一起工作的类一起工作。
即使用聚合而不是继承。

一种事物可在多种维度变化（如两个维度，每个维度三种可能）时，如果为每一种可能创建一个子类，则每增加一个维度上的可能需要增加多个类，这会造成类爆炸（3*3=9）。若使用桥接模式，使用类聚合，而非继承，将可缓解类爆炸，并增强可扩展性。

[参考](http://www.jasongj.com/design_pattern/bridge/)

### 适配器模式（Adapter Pattern）

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

其实就是封装了一层。

[参考](http://www.jasongj.com/design_pattern/adapter/)


### 装饰者模式



### 代理模式

对外隐藏真实的对象，封装一层。

### 组合模式 (Composite)

将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性

组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。组合模式让你可以优化处理递归或分级数据结构。


### 外观模式（Facade）

外观模式，我们通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。
例子1：一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。该电源总开关可以同时控制上述所有电器设备，电源总开关即为该系统的外观模式设计。

[参考](https://blog.csdn.net/hguisu/article/details/7533759)

一图胜千言
![](http://my.csdn.net/uploads/201205/04/1336116055_1914.jpg)
### 享元模式（Flyweight）


在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

可以参考源码FlyWeightDemo

所谓“享元”，指的是“共享元数据”【不一定准确】，也就是说，如果对象一致，就没有必要新建数据。采用的方法是在内存中放置一个map。

[参考](http://www.jasongj.com/design_pattern/flyweight/)

## 行为型模式

### 策略模式（Strategy Pattern）

策略模式优点
策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法（策略），并且可以灵活地增加新的算法（策略）。
策略模式通过Context类提供了管理具体策略类（算法族）的办法。
结合简单工厂模式和Annotation，策略模式可以方便的在不修改客户端代码的前提下切换算法（策略）。
策略模式缺点
传统的策略模式实现方式中，客户端必须知道所有的具体策略类，并须自行显示决定使用哪一个策略类。但通过本文介绍的通过和Annotation和简单工厂模式结合，可以有效避免该问题
如果使用不当，策略模式可能创建很多具体策略类的实例，但可以通过使用上文《Java设计模式（十一） 享元模式》介绍的享元模式有效减少对象的数量。

[参考](http://www.jasongj.com/design_pattern/strategy/)

### 解释器模式（Interpreter）

就是一个语法解释器，之前做测试系统的时候实现过。

### 命令模式（Command）

将来自客户端的请求传入一个对象，从而使你可用不同的请求对客户进行参数化。用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。分离变化与不变的因素。

在面向对象的程序设计中，一个对象调用另一个对象，一般情况下的调用过程是：创建目标对象实例；设置调用参数；调用目标对象的方法。

但在有些情况下有必要使用一个专门的类对这种调用过程加以封装，我们把这种专门的类称作command类。

Command模式可应用于
a）整个调用过程比较繁杂，或者存在多处这种调用。这时，使用Command类对该调用加以封装，便于功能的再利用。
b）调用前后需要对调用参数进行某些处理。
c）调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等。

Command模式有如下效果：
a）将调用操作的对象和知道如何实现该操作的对象解耦。
b）Command是头等对象。他们可以像其他对象一样被操作和扩展。
c）你可将多个命令装配成一个符合命令。
d）增加新的Command很容易，因为这无需改变现有的类。

### 观察者模式

这个很熟悉，就不说了。

### 迭代器模式（Iterator）

常见。

### 模板方法模式

这个用的最多，就不解释了。


### 访问者模式（Visitor）


[参考](https://blog.csdn.net/zhengzhb/article/details/7489639)
